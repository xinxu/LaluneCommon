// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pvp.proto

#ifndef PROTOBUF_pvp_2eproto__INCLUDED
#define PROTOBUF_pvp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace boids {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pvp_2eproto();
void protobuf_AssignDesc_pvp_2eproto();
void protobuf_ShutdownFile_pvp_2eproto();

class UnitData;
class ForceData;
class GameInitData;
class UserOperation;
class UserOperationPackage;
class GameMessage;
class PvpMessage;

enum UserOperation_OperationType {
  UserOperation_OperationType_EnterGame = 1,
  UserOperation_OperationType_QuitGame = 2,
  UserOperation_OperationType_Move = 3,
  UserOperation_OperationType_UseSkill = 4
};
bool UserOperation_OperationType_IsValid(int value);
const UserOperation_OperationType UserOperation_OperationType_OperationType_MIN = UserOperation_OperationType_EnterGame;
const UserOperation_OperationType UserOperation_OperationType_OperationType_MAX = UserOperation_OperationType_UseSkill;
const int UserOperation_OperationType_OperationType_ARRAYSIZE = UserOperation_OperationType_OperationType_MAX + 1;

const ::google_lalune::protobuf::EnumDescriptor* UserOperation_OperationType_descriptor();
inline const ::std::string& UserOperation_OperationType_Name(UserOperation_OperationType value) {
  return ::google_lalune::protobuf::internal::NameOfEnum(
    UserOperation_OperationType_descriptor(), value);
}
inline bool UserOperation_OperationType_Parse(
    const ::std::string& name, UserOperation_OperationType* value) {
  return ::google_lalune::protobuf::internal::ParseNamedEnum<UserOperation_OperationType>(
    UserOperation_OperationType_descriptor(), name, value);
}
enum GameMessage_MessageType {
  GameMessage_MessageType_HeartBeat = 1,
  GameMessage_MessageType_GameInitData = 2,
  GameMessage_MessageType_UserOperation = 3,
  GameMessage_MessageType_UserOperationPackage = 4
};
bool GameMessage_MessageType_IsValid(int value);
const GameMessage_MessageType GameMessage_MessageType_MessageType_MIN = GameMessage_MessageType_HeartBeat;
const GameMessage_MessageType GameMessage_MessageType_MessageType_MAX = GameMessage_MessageType_UserOperationPackage;
const int GameMessage_MessageType_MessageType_ARRAYSIZE = GameMessage_MessageType_MessageType_MAX + 1;

const ::google_lalune::protobuf::EnumDescriptor* GameMessage_MessageType_descriptor();
inline const ::std::string& GameMessage_MessageType_Name(GameMessage_MessageType value) {
  return ::google_lalune::protobuf::internal::NameOfEnum(
    GameMessage_MessageType_descriptor(), value);
}
inline bool GameMessage_MessageType_Parse(
    const ::std::string& name, GameMessage_MessageType* value) {
  return ::google_lalune::protobuf::internal::ParseNamedEnum<GameMessage_MessageType>(
    GameMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class UnitData : public ::google_lalune::protobuf::Message {
 public:
  UnitData();
  virtual ~UnitData();

  UnitData(const UnitData& from);

  inline UnitData& operator=(const UnitData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const UnitData& default_instance();

  void Swap(UnitData* other);

  // implements Message ----------------------------------------------

  UnitData* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const UnitData& from);
  void MergeFrom(const UnitData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string unit_name = 1;
  inline bool has_unit_name() const;
  inline void clear_unit_name();
  static const int kUnitNameFieldNumber = 1;
  inline const ::std::string& unit_name() const;
  inline void set_unit_name(const ::std::string& value);
  inline void set_unit_name(const char* value);
  inline void set_unit_name(const char* value, size_t size);
  inline ::std::string* mutable_unit_name();
  inline ::std::string* release_unit_name();
  inline void set_allocated_unit_name(::std::string* unit_name);

  // required uint32 unit_level = 2;
  inline bool has_unit_level() const;
  inline void clear_unit_level();
  static const int kUnitLevelFieldNumber = 2;
  inline ::google_lalune::protobuf::uint32 unit_level() const;
  inline void set_unit_level(::google_lalune::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:boids.UnitData)
 private:
  inline void set_has_unit_name();
  inline void clear_has_unit_name();
  inline void set_has_unit_level();
  inline void clear_has_unit_level();

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unit_name_;
  ::google_lalune::protobuf::uint32 unit_level_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static UnitData* default_instance_;
};
// -------------------------------------------------------------------

class ForceData : public ::google_lalune::protobuf::Message {
 public:
  ForceData();
  virtual ~ForceData();

  ForceData(const ForceData& from);

  inline ForceData& operator=(const ForceData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const ForceData& default_instance();

  void Swap(ForceData* other);

  // implements Message ----------------------------------------------

  ForceData* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const ForceData& from);
  void MergeFrom(const ForceData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required uint32 force_id = 2;
  inline bool has_force_id() const;
  inline void clear_force_id();
  static const int kForceIdFieldNumber = 2;
  inline ::google_lalune::protobuf::uint32 force_id() const;
  inline void set_force_id(::google_lalune::protobuf::uint32 value);

  // repeated .boids.UnitData units = 3;
  inline int units_size() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 3;
  inline const ::boids::UnitData& units(int index) const;
  inline ::boids::UnitData* mutable_units(int index);
  inline ::boids::UnitData* add_units();
  inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::UnitData >&
      units() const;
  inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::UnitData >*
      mutable_units();

  // @@protoc_insertion_point(class_scope:boids.ForceData)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_force_id();
  inline void clear_has_force_id();

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_id_;
  ::google_lalune::protobuf::RepeatedPtrField< ::boids::UnitData > units_;
  ::google_lalune::protobuf::uint32 force_id_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static ForceData* default_instance_;
};
// -------------------------------------------------------------------

class GameInitData : public ::google_lalune::protobuf::Message {
 public:
  GameInitData();
  virtual ~GameInitData();

  GameInitData(const GameInitData& from);

  inline GameInitData& operator=(const GameInitData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const GameInitData& default_instance();

  void Swap(GameInitData* other);

  // implements Message ----------------------------------------------

  GameInitData* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const GameInitData& from);
  void MergeFrom(const GameInitData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .boids.ForceData forces = 1;
  inline int forces_size() const;
  inline void clear_forces();
  static const int kForcesFieldNumber = 1;
  inline const ::boids::ForceData& forces(int index) const;
  inline ::boids::ForceData* mutable_forces(int index);
  inline ::boids::ForceData* add_forces();
  inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::ForceData >&
      forces() const;
  inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::ForceData >*
      mutable_forces();

  // @@protoc_insertion_point(class_scope:boids.GameInitData)
 private:

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google_lalune::protobuf::RepeatedPtrField< ::boids::ForceData > forces_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static GameInitData* default_instance_;
};
// -------------------------------------------------------------------

class UserOperation : public ::google_lalune::protobuf::Message {
 public:
  UserOperation();
  virtual ~UserOperation();

  UserOperation(const UserOperation& from);

  inline UserOperation& operator=(const UserOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const UserOperation& default_instance();

  void Swap(UserOperation* other);

  // implements Message ----------------------------------------------

  UserOperation* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const UserOperation& from);
  void MergeFrom(const UserOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserOperation_OperationType OperationType;
  static const OperationType EnterGame = UserOperation_OperationType_EnterGame;
  static const OperationType QuitGame = UserOperation_OperationType_QuitGame;
  static const OperationType Move = UserOperation_OperationType_Move;
  static const OperationType UseSkill = UserOperation_OperationType_UseSkill;
  static inline bool OperationType_IsValid(int value) {
    return UserOperation_OperationType_IsValid(value);
  }
  static const OperationType OperationType_MIN =
    UserOperation_OperationType_OperationType_MIN;
  static const OperationType OperationType_MAX =
    UserOperation_OperationType_OperationType_MAX;
  static const int OperationType_ARRAYSIZE =
    UserOperation_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google_lalune::protobuf::EnumDescriptor*
  OperationType_descriptor() {
    return UserOperation_OperationType_descriptor();
  }
  static inline const ::std::string& OperationType_Name(OperationType value) {
    return UserOperation_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(const ::std::string& name,
      OperationType* value) {
    return UserOperation_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional .boids.UserOperation.OperationType op_type = 2;
  inline bool has_op_type() const;
  inline void clear_op_type();
  static const int kOpTypeFieldNumber = 2;
  inline ::boids::UserOperation_OperationType op_type() const;
  inline void set_op_type(::boids::UserOperation_OperationType value);

  // optional uint32 game_id = 3;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 3;
  inline ::google_lalune::protobuf::uint32 game_id() const;
  inline void set_game_id(::google_lalune::protobuf::uint32 value);

  // optional uint32 unit_id = 4;
  inline bool has_unit_id() const;
  inline void clear_unit_id();
  static const int kUnitIdFieldNumber = 4;
  inline ::google_lalune::protobuf::uint32 unit_id() const;
  inline void set_unit_id(::google_lalune::protobuf::uint32 value);

  // optional uint32 skill_id = 5;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 5;
  inline ::google_lalune::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google_lalune::protobuf::uint32 value);

  // optional uint32 skill_range = 9;
  inline bool has_skill_range() const;
  inline void clear_skill_range();
  static const int kSkillRangeFieldNumber = 9;
  inline ::google_lalune::protobuf::uint32 skill_range() const;
  inline void set_skill_range(::google_lalune::protobuf::uint32 value);

  // optional int32 dir_x = 6;
  inline bool has_dir_x() const;
  inline void clear_dir_x();
  static const int kDirXFieldNumber = 6;
  inline ::google_lalune::protobuf::int32 dir_x() const;
  inline void set_dir_x(::google_lalune::protobuf::int32 value);

  // optional int32 dir_y = 7;
  inline bool has_dir_y() const;
  inline void clear_dir_y();
  static const int kDirYFieldNumber = 7;
  inline ::google_lalune::protobuf::int32 dir_y() const;
  inline void set_dir_y(::google_lalune::protobuf::int32 value);

  // optional uint32 timestamp = 8;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  inline ::google_lalune::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google_lalune::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:boids.UserOperation)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_op_type();
  inline void clear_has_op_type();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_unit_id();
  inline void clear_has_unit_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_range();
  inline void clear_has_skill_range();
  inline void set_has_dir_x();
  inline void clear_has_dir_x();
  inline void set_has_dir_y();
  inline void clear_has_dir_y();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_id_;
  int op_type_;
  ::google_lalune::protobuf::uint32 game_id_;
  ::google_lalune::protobuf::uint32 unit_id_;
  ::google_lalune::protobuf::uint32 skill_id_;
  ::google_lalune::protobuf::uint32 skill_range_;
  ::google_lalune::protobuf::int32 dir_x_;
  ::google_lalune::protobuf::int32 dir_y_;
  ::google_lalune::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static UserOperation* default_instance_;
};
// -------------------------------------------------------------------

class UserOperationPackage : public ::google_lalune::protobuf::Message {
 public:
  UserOperationPackage();
  virtual ~UserOperationPackage();

  UserOperationPackage(const UserOperationPackage& from);

  inline UserOperationPackage& operator=(const UserOperationPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const UserOperationPackage& default_instance();

  void Swap(UserOperationPackage* other);

  // implements Message ----------------------------------------------

  UserOperationPackage* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const UserOperationPackage& from);
  void MergeFrom(const UserOperationPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .boids.UserOperation operations = 1;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 1;
  inline const ::boids::UserOperation& operations(int index) const;
  inline ::boids::UserOperation* mutable_operations(int index);
  inline ::boids::UserOperation* add_operations();
  inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::UserOperation >&
      operations() const;
  inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::UserOperation >*
      mutable_operations();

  // @@protoc_insertion_point(class_scope:boids.UserOperationPackage)
 private:

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google_lalune::protobuf::RepeatedPtrField< ::boids::UserOperation > operations_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static UserOperationPackage* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage : public ::google_lalune::protobuf::Message {
 public:
  GameMessage();
  virtual ~GameMessage();

  GameMessage(const GameMessage& from);

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const GameMessage& default_instance();

  void Swap(GameMessage* other);

  // implements Message ----------------------------------------------

  GameMessage* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const GameMessage& from);
  void MergeFrom(const GameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameMessage_MessageType MessageType;
  static const MessageType HeartBeat = GameMessage_MessageType_HeartBeat;
  static const MessageType GameInitData = GameMessage_MessageType_GameInitData;
  static const MessageType UserOperation = GameMessage_MessageType_UserOperation;
  static const MessageType UserOperationPackage = GameMessage_MessageType_UserOperationPackage;
  static inline bool MessageType_IsValid(int value) {
    return GameMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    GameMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    GameMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    GameMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google_lalune::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return GameMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return GameMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return GameMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .boids.GameMessage.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::boids::GameMessage_MessageType type() const;
  inline void set_type(::boids::GameMessage_MessageType value);

  // optional .boids.GameInitData game_init_data = 2;
  inline bool has_game_init_data() const;
  inline void clear_game_init_data();
  static const int kGameInitDataFieldNumber = 2;
  inline const ::boids::GameInitData& game_init_data() const;
  inline ::boids::GameInitData* mutable_game_init_data();
  inline ::boids::GameInitData* release_game_init_data();
  inline void set_allocated_game_init_data(::boids::GameInitData* game_init_data);

  // optional .boids.UserOperation user_op = 3;
  inline bool has_user_op() const;
  inline void clear_user_op();
  static const int kUserOpFieldNumber = 3;
  inline const ::boids::UserOperation& user_op() const;
  inline ::boids::UserOperation* mutable_user_op();
  inline ::boids::UserOperation* release_user_op();
  inline void set_allocated_user_op(::boids::UserOperation* user_op);

  // optional .boids.UserOperationPackage user_op_package = 4;
  inline bool has_user_op_package() const;
  inline void clear_user_op_package();
  static const int kUserOpPackageFieldNumber = 4;
  inline const ::boids::UserOperationPackage& user_op_package() const;
  inline ::boids::UserOperationPackage* mutable_user_op_package();
  inline ::boids::UserOperationPackage* release_user_op_package();
  inline void set_allocated_user_op_package(::boids::UserOperationPackage* user_op_package);

  // @@protoc_insertion_point(class_scope:boids.GameMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_game_init_data();
  inline void clear_has_game_init_data();
  inline void set_has_user_op();
  inline void clear_has_user_op();
  inline void set_has_user_op_package();
  inline void clear_has_user_op_package();

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::boids::GameInitData* game_init_data_;
  ::boids::UserOperation* user_op_;
  ::boids::UserOperationPackage* user_op_package_;
  int type_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static GameMessage* default_instance_;
};
// -------------------------------------------------------------------

class PvpMessage : public ::google_lalune::protobuf::Message {
 public:
  PvpMessage();
  virtual ~PvpMessage();

  PvpMessage(const PvpMessage& from);

  inline PvpMessage& operator=(const PvpMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_lalune::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_lalune::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_lalune::protobuf::Descriptor* descriptor();
  static const PvpMessage& default_instance();

  void Swap(PvpMessage* other);

  // implements Message ----------------------------------------------

  PvpMessage* New() const;
  void CopyFrom(const ::google_lalune::protobuf::Message& from);
  void MergeFrom(const ::google_lalune::protobuf::Message& from);
  void CopyFrom(const PvpMessage& from);
  void MergeFrom(const PvpMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_lalune::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_lalune::protobuf::io::CodedOutputStream* output) const;
  ::google_lalune::protobuf::uint8* SerializeWithCachedSizesToArray(::google_lalune::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google_lalune::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google_lalune::protobuf::uint32 version() const;
  inline void set_version(::google_lalune::protobuf::uint32 value);

  // required uint32 proto_id = 2;
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 2;
  inline ::google_lalune::protobuf::uint32 proto_id() const;
  inline void set_proto_id(::google_lalune::protobuf::uint32 value);

  // required uint32 seq_no = 3;
  inline bool has_seq_no() const;
  inline void clear_seq_no();
  static const int kSeqNoFieldNumber = 3;
  inline ::google_lalune::protobuf::uint32 seq_no() const;
  inline void set_seq_no(::google_lalune::protobuf::uint32 value);

  // required uint32 ack_no = 4;
  inline bool has_ack_no() const;
  inline void clear_ack_no();
  static const int kAckNoFieldNumber = 4;
  inline ::google_lalune::protobuf::uint32 ack_no() const;
  inline void set_ack_no(::google_lalune::protobuf::uint32 value);

  // required uint32 ack_bits = 5;
  inline bool has_ack_bits() const;
  inline void clear_ack_bits();
  static const int kAckBitsFieldNumber = 5;
  inline ::google_lalune::protobuf::uint32 ack_bits() const;
  inline void set_ack_bits(::google_lalune::protobuf::uint32 value);

  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:boids.PvpMessage)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_proto_id();
  inline void clear_has_proto_id();
  inline void set_has_seq_no();
  inline void clear_has_seq_no();
  inline void set_has_ack_no();
  inline void clear_has_ack_no();
  inline void set_has_ack_bits();
  inline void clear_has_ack_bits();
  inline void set_has_data();
  inline void clear_has_data();

  ::google_lalune::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_lalune::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google_lalune::protobuf::uint32 version_;
  ::google_lalune::protobuf::uint32 proto_id_;
  ::google_lalune::protobuf::uint32 seq_no_;
  ::google_lalune::protobuf::uint32 ack_no_;
  ::std::string* data_;
  ::google_lalune::protobuf::uint32 ack_bits_;
  friend void  protobuf_AddDesc_pvp_2eproto();
  friend void protobuf_AssignDesc_pvp_2eproto();
  friend void protobuf_ShutdownFile_pvp_2eproto();

  void InitAsDefaultInstance();
  static PvpMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// UnitData

// required string unit_name = 1;
inline bool UnitData::has_unit_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitData::set_has_unit_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitData::clear_has_unit_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitData::clear_unit_name() {
  if (unit_name_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_name_->clear();
  }
  clear_has_unit_name();
}
inline const ::std::string& UnitData::unit_name() const {
  // @@protoc_insertion_point(field_get:boids.UnitData.unit_name)
  return *unit_name_;
}
inline void UnitData::set_unit_name(const ::std::string& value) {
  set_has_unit_name();
  if (unit_name_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_name_ = new ::std::string;
  }
  unit_name_->assign(value);
  // @@protoc_insertion_point(field_set:boids.UnitData.unit_name)
}
inline void UnitData::set_unit_name(const char* value) {
  set_has_unit_name();
  if (unit_name_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_name_ = new ::std::string;
  }
  unit_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:boids.UnitData.unit_name)
}
inline void UnitData::set_unit_name(const char* value, size_t size) {
  set_has_unit_name();
  if (unit_name_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_name_ = new ::std::string;
  }
  unit_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boids.UnitData.unit_name)
}
inline ::std::string* UnitData::mutable_unit_name() {
  set_has_unit_name();
  if (unit_name_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boids.UnitData.unit_name)
  return unit_name_;
}
inline ::std::string* UnitData::release_unit_name() {
  clear_has_unit_name();
  if (unit_name_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_name_;
    unit_name_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnitData::set_allocated_unit_name(::std::string* unit_name) {
  if (unit_name_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_name_;
  }
  if (unit_name) {
    set_has_unit_name();
    unit_name_ = unit_name;
  } else {
    clear_has_unit_name();
    unit_name_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boids.UnitData.unit_name)
}

// required uint32 unit_level = 2;
inline bool UnitData::has_unit_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitData::set_has_unit_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitData::clear_has_unit_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitData::clear_unit_level() {
  unit_level_ = 0u;
  clear_has_unit_level();
}
inline ::google_lalune::protobuf::uint32 UnitData::unit_level() const {
  // @@protoc_insertion_point(field_get:boids.UnitData.unit_level)
  return unit_level_;
}
inline void UnitData::set_unit_level(::google_lalune::protobuf::uint32 value) {
  set_has_unit_level();
  unit_level_ = value;
  // @@protoc_insertion_point(field_set:boids.UnitData.unit_level)
}

// -------------------------------------------------------------------

// ForceData

// required string user_id = 1;
inline bool ForceData::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForceData::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForceData::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForceData::clear_user_id() {
  if (user_id_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& ForceData::user_id() const {
  // @@protoc_insertion_point(field_get:boids.ForceData.user_id)
  return *user_id_;
}
inline void ForceData::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:boids.ForceData.user_id)
}
inline void ForceData::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boids.ForceData.user_id)
}
inline void ForceData::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boids.ForceData.user_id)
}
inline ::std::string* ForceData::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boids.ForceData.user_id)
  return user_id_;
}
inline ::std::string* ForceData::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ForceData::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boids.ForceData.user_id)
}

// required uint32 force_id = 2;
inline bool ForceData::has_force_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForceData::set_has_force_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForceData::clear_has_force_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForceData::clear_force_id() {
  force_id_ = 0u;
  clear_has_force_id();
}
inline ::google_lalune::protobuf::uint32 ForceData::force_id() const {
  // @@protoc_insertion_point(field_get:boids.ForceData.force_id)
  return force_id_;
}
inline void ForceData::set_force_id(::google_lalune::protobuf::uint32 value) {
  set_has_force_id();
  force_id_ = value;
  // @@protoc_insertion_point(field_set:boids.ForceData.force_id)
}

// repeated .boids.UnitData units = 3;
inline int ForceData::units_size() const {
  return units_.size();
}
inline void ForceData::clear_units() {
  units_.Clear();
}
inline const ::boids::UnitData& ForceData::units(int index) const {
  // @@protoc_insertion_point(field_get:boids.ForceData.units)
  return units_.Get(index);
}
inline ::boids::UnitData* ForceData::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:boids.ForceData.units)
  return units_.Mutable(index);
}
inline ::boids::UnitData* ForceData::add_units() {
  // @@protoc_insertion_point(field_add:boids.ForceData.units)
  return units_.Add();
}
inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::UnitData >&
ForceData::units() const {
  // @@protoc_insertion_point(field_list:boids.ForceData.units)
  return units_;
}
inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::UnitData >*
ForceData::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:boids.ForceData.units)
  return &units_;
}

// -------------------------------------------------------------------

// GameInitData

// repeated .boids.ForceData forces = 1;
inline int GameInitData::forces_size() const {
  return forces_.size();
}
inline void GameInitData::clear_forces() {
  forces_.Clear();
}
inline const ::boids::ForceData& GameInitData::forces(int index) const {
  // @@protoc_insertion_point(field_get:boids.GameInitData.forces)
  return forces_.Get(index);
}
inline ::boids::ForceData* GameInitData::mutable_forces(int index) {
  // @@protoc_insertion_point(field_mutable:boids.GameInitData.forces)
  return forces_.Mutable(index);
}
inline ::boids::ForceData* GameInitData::add_forces() {
  // @@protoc_insertion_point(field_add:boids.GameInitData.forces)
  return forces_.Add();
}
inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::ForceData >&
GameInitData::forces() const {
  // @@protoc_insertion_point(field_list:boids.GameInitData.forces)
  return forces_;
}
inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::ForceData >*
GameInitData::mutable_forces() {
  // @@protoc_insertion_point(field_mutable_list:boids.GameInitData.forces)
  return &forces_;
}

// -------------------------------------------------------------------

// UserOperation

// required string user_id = 1;
inline bool UserOperation::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOperation::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOperation::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOperation::clear_user_id() {
  if (user_id_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& UserOperation::user_id() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.user_id)
  return *user_id_;
}
inline void UserOperation::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:boids.UserOperation.user_id)
}
inline void UserOperation::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:boids.UserOperation.user_id)
}
inline void UserOperation::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boids.UserOperation.user_id)
}
inline ::std::string* UserOperation::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boids.UserOperation.user_id)
  return user_id_;
}
inline ::std::string* UserOperation::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserOperation::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boids.UserOperation.user_id)
}

// optional .boids.UserOperation.OperationType op_type = 2;
inline bool UserOperation::has_op_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOperation::set_has_op_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOperation::clear_has_op_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOperation::clear_op_type() {
  op_type_ = 1;
  clear_has_op_type();
}
inline ::boids::UserOperation_OperationType UserOperation::op_type() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.op_type)
  return static_cast< ::boids::UserOperation_OperationType >(op_type_);
}
inline void UserOperation::set_op_type(::boids::UserOperation_OperationType value) {
  assert(::boids::UserOperation_OperationType_IsValid(value));
  set_has_op_type();
  op_type_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.op_type)
}

// optional uint32 game_id = 3;
inline bool UserOperation::has_game_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOperation::set_has_game_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOperation::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOperation::clear_game_id() {
  game_id_ = 0u;
  clear_has_game_id();
}
inline ::google_lalune::protobuf::uint32 UserOperation::game_id() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.game_id)
  return game_id_;
}
inline void UserOperation::set_game_id(::google_lalune::protobuf::uint32 value) {
  set_has_game_id();
  game_id_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.game_id)
}

// optional uint32 unit_id = 4;
inline bool UserOperation::has_unit_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserOperation::set_has_unit_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserOperation::clear_has_unit_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserOperation::clear_unit_id() {
  unit_id_ = 0u;
  clear_has_unit_id();
}
inline ::google_lalune::protobuf::uint32 UserOperation::unit_id() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.unit_id)
  return unit_id_;
}
inline void UserOperation::set_unit_id(::google_lalune::protobuf::uint32 value) {
  set_has_unit_id();
  unit_id_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.unit_id)
}

// optional uint32 skill_id = 5;
inline bool UserOperation::has_skill_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserOperation::set_has_skill_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserOperation::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserOperation::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google_lalune::protobuf::uint32 UserOperation::skill_id() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.skill_id)
  return skill_id_;
}
inline void UserOperation::set_skill_id(::google_lalune::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.skill_id)
}

// optional uint32 skill_range = 9;
inline bool UserOperation::has_skill_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserOperation::set_has_skill_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserOperation::clear_has_skill_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserOperation::clear_skill_range() {
  skill_range_ = 0u;
  clear_has_skill_range();
}
inline ::google_lalune::protobuf::uint32 UserOperation::skill_range() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.skill_range)
  return skill_range_;
}
inline void UserOperation::set_skill_range(::google_lalune::protobuf::uint32 value) {
  set_has_skill_range();
  skill_range_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.skill_range)
}

// optional int32 dir_x = 6;
inline bool UserOperation::has_dir_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserOperation::set_has_dir_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserOperation::clear_has_dir_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserOperation::clear_dir_x() {
  dir_x_ = 0;
  clear_has_dir_x();
}
inline ::google_lalune::protobuf::int32 UserOperation::dir_x() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.dir_x)
  return dir_x_;
}
inline void UserOperation::set_dir_x(::google_lalune::protobuf::int32 value) {
  set_has_dir_x();
  dir_x_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.dir_x)
}

// optional int32 dir_y = 7;
inline bool UserOperation::has_dir_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserOperation::set_has_dir_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserOperation::clear_has_dir_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserOperation::clear_dir_y() {
  dir_y_ = 0;
  clear_has_dir_y();
}
inline ::google_lalune::protobuf::int32 UserOperation::dir_y() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.dir_y)
  return dir_y_;
}
inline void UserOperation::set_dir_y(::google_lalune::protobuf::int32 value) {
  set_has_dir_y();
  dir_y_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.dir_y)
}

// optional uint32 timestamp = 8;
inline bool UserOperation::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserOperation::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserOperation::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserOperation::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google_lalune::protobuf::uint32 UserOperation::timestamp() const {
  // @@protoc_insertion_point(field_get:boids.UserOperation.timestamp)
  return timestamp_;
}
inline void UserOperation::set_timestamp(::google_lalune::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:boids.UserOperation.timestamp)
}

// -------------------------------------------------------------------

// UserOperationPackage

// repeated .boids.UserOperation operations = 1;
inline int UserOperationPackage::operations_size() const {
  return operations_.size();
}
inline void UserOperationPackage::clear_operations() {
  operations_.Clear();
}
inline const ::boids::UserOperation& UserOperationPackage::operations(int index) const {
  // @@protoc_insertion_point(field_get:boids.UserOperationPackage.operations)
  return operations_.Get(index);
}
inline ::boids::UserOperation* UserOperationPackage::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:boids.UserOperationPackage.operations)
  return operations_.Mutable(index);
}
inline ::boids::UserOperation* UserOperationPackage::add_operations() {
  // @@protoc_insertion_point(field_add:boids.UserOperationPackage.operations)
  return operations_.Add();
}
inline const ::google_lalune::protobuf::RepeatedPtrField< ::boids::UserOperation >&
UserOperationPackage::operations() const {
  // @@protoc_insertion_point(field_list:boids.UserOperationPackage.operations)
  return operations_;
}
inline ::google_lalune::protobuf::RepeatedPtrField< ::boids::UserOperation >*
UserOperationPackage::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:boids.UserOperationPackage.operations)
  return &operations_;
}

// -------------------------------------------------------------------

// GameMessage

// required .boids.GameMessage.MessageType type = 1;
inline bool GameMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::boids::GameMessage_MessageType GameMessage::type() const {
  // @@protoc_insertion_point(field_get:boids.GameMessage.type)
  return static_cast< ::boids::GameMessage_MessageType >(type_);
}
inline void GameMessage::set_type(::boids::GameMessage_MessageType value) {
  assert(::boids::GameMessage_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:boids.GameMessage.type)
}

// optional .boids.GameInitData game_init_data = 2;
inline bool GameMessage::has_game_init_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage::set_has_game_init_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage::clear_has_game_init_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage::clear_game_init_data() {
  if (game_init_data_ != NULL) game_init_data_->::boids::GameInitData::Clear();
  clear_has_game_init_data();
}
inline const ::boids::GameInitData& GameMessage::game_init_data() const {
  // @@protoc_insertion_point(field_get:boids.GameMessage.game_init_data)
  return game_init_data_ != NULL ? *game_init_data_ : *default_instance_->game_init_data_;
}
inline ::boids::GameInitData* GameMessage::mutable_game_init_data() {
  set_has_game_init_data();
  if (game_init_data_ == NULL) game_init_data_ = new ::boids::GameInitData;
  // @@protoc_insertion_point(field_mutable:boids.GameMessage.game_init_data)
  return game_init_data_;
}
inline ::boids::GameInitData* GameMessage::release_game_init_data() {
  clear_has_game_init_data();
  ::boids::GameInitData* temp = game_init_data_;
  game_init_data_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_game_init_data(::boids::GameInitData* game_init_data) {
  delete game_init_data_;
  game_init_data_ = game_init_data;
  if (game_init_data) {
    set_has_game_init_data();
  } else {
    clear_has_game_init_data();
  }
  // @@protoc_insertion_point(field_set_allocated:boids.GameMessage.game_init_data)
}

// optional .boids.UserOperation user_op = 3;
inline bool GameMessage::has_user_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMessage::set_has_user_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMessage::clear_has_user_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMessage::clear_user_op() {
  if (user_op_ != NULL) user_op_->::boids::UserOperation::Clear();
  clear_has_user_op();
}
inline const ::boids::UserOperation& GameMessage::user_op() const {
  // @@protoc_insertion_point(field_get:boids.GameMessage.user_op)
  return user_op_ != NULL ? *user_op_ : *default_instance_->user_op_;
}
inline ::boids::UserOperation* GameMessage::mutable_user_op() {
  set_has_user_op();
  if (user_op_ == NULL) user_op_ = new ::boids::UserOperation;
  // @@protoc_insertion_point(field_mutable:boids.GameMessage.user_op)
  return user_op_;
}
inline ::boids::UserOperation* GameMessage::release_user_op() {
  clear_has_user_op();
  ::boids::UserOperation* temp = user_op_;
  user_op_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_user_op(::boids::UserOperation* user_op) {
  delete user_op_;
  user_op_ = user_op;
  if (user_op) {
    set_has_user_op();
  } else {
    clear_has_user_op();
  }
  // @@protoc_insertion_point(field_set_allocated:boids.GameMessage.user_op)
}

// optional .boids.UserOperationPackage user_op_package = 4;
inline bool GameMessage::has_user_op_package() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameMessage::set_has_user_op_package() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameMessage::clear_has_user_op_package() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameMessage::clear_user_op_package() {
  if (user_op_package_ != NULL) user_op_package_->::boids::UserOperationPackage::Clear();
  clear_has_user_op_package();
}
inline const ::boids::UserOperationPackage& GameMessage::user_op_package() const {
  // @@protoc_insertion_point(field_get:boids.GameMessage.user_op_package)
  return user_op_package_ != NULL ? *user_op_package_ : *default_instance_->user_op_package_;
}
inline ::boids::UserOperationPackage* GameMessage::mutable_user_op_package() {
  set_has_user_op_package();
  if (user_op_package_ == NULL) user_op_package_ = new ::boids::UserOperationPackage;
  // @@protoc_insertion_point(field_mutable:boids.GameMessage.user_op_package)
  return user_op_package_;
}
inline ::boids::UserOperationPackage* GameMessage::release_user_op_package() {
  clear_has_user_op_package();
  ::boids::UserOperationPackage* temp = user_op_package_;
  user_op_package_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_user_op_package(::boids::UserOperationPackage* user_op_package) {
  delete user_op_package_;
  user_op_package_ = user_op_package;
  if (user_op_package) {
    set_has_user_op_package();
  } else {
    clear_has_user_op_package();
  }
  // @@protoc_insertion_point(field_set_allocated:boids.GameMessage.user_op_package)
}

// -------------------------------------------------------------------

// PvpMessage

// required uint32 version = 1;
inline bool PvpMessage::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpMessage::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpMessage::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google_lalune::protobuf::uint32 PvpMessage::version() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.version)
  return version_;
}
inline void PvpMessage::set_version(::google_lalune::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:boids.PvpMessage.version)
}

// required uint32 proto_id = 2;
inline bool PvpMessage::has_proto_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpMessage::set_has_proto_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpMessage::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpMessage::clear_proto_id() {
  proto_id_ = 0u;
  clear_has_proto_id();
}
inline ::google_lalune::protobuf::uint32 PvpMessage::proto_id() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.proto_id)
  return proto_id_;
}
inline void PvpMessage::set_proto_id(::google_lalune::protobuf::uint32 value) {
  set_has_proto_id();
  proto_id_ = value;
  // @@protoc_insertion_point(field_set:boids.PvpMessage.proto_id)
}

// required uint32 seq_no = 3;
inline bool PvpMessage::has_seq_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpMessage::set_has_seq_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpMessage::clear_has_seq_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpMessage::clear_seq_no() {
  seq_no_ = 0u;
  clear_has_seq_no();
}
inline ::google_lalune::protobuf::uint32 PvpMessage::seq_no() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.seq_no)
  return seq_no_;
}
inline void PvpMessage::set_seq_no(::google_lalune::protobuf::uint32 value) {
  set_has_seq_no();
  seq_no_ = value;
  // @@protoc_insertion_point(field_set:boids.PvpMessage.seq_no)
}

// required uint32 ack_no = 4;
inline bool PvpMessage::has_ack_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpMessage::set_has_ack_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpMessage::clear_has_ack_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpMessage::clear_ack_no() {
  ack_no_ = 0u;
  clear_has_ack_no();
}
inline ::google_lalune::protobuf::uint32 PvpMessage::ack_no() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.ack_no)
  return ack_no_;
}
inline void PvpMessage::set_ack_no(::google_lalune::protobuf::uint32 value) {
  set_has_ack_no();
  ack_no_ = value;
  // @@protoc_insertion_point(field_set:boids.PvpMessage.ack_no)
}

// required uint32 ack_bits = 5;
inline bool PvpMessage::has_ack_bits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpMessage::set_has_ack_bits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpMessage::clear_has_ack_bits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpMessage::clear_ack_bits() {
  ack_bits_ = 0u;
  clear_has_ack_bits();
}
inline ::google_lalune::protobuf::uint32 PvpMessage::ack_bits() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.ack_bits)
  return ack_bits_;
}
inline void PvpMessage::set_ack_bits(::google_lalune::protobuf::uint32 value) {
  set_has_ack_bits();
  ack_bits_ = value;
  // @@protoc_insertion_point(field_set:boids.PvpMessage.ack_bits)
}

// optional bytes data = 6;
inline bool PvpMessage::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvpMessage::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvpMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvpMessage::clear_data() {
  if (data_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PvpMessage::data() const {
  // @@protoc_insertion_point(field_get:boids.PvpMessage.data)
  return *data_;
}
inline void PvpMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:boids.PvpMessage.data)
}
inline void PvpMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:boids.PvpMessage.data)
}
inline void PvpMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:boids.PvpMessage.data)
}
inline ::std::string* PvpMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:boids.PvpMessage.data)
  return data_;
}
inline ::std::string* PvpMessage::release_data() {
  clear_has_data();
  if (data_ == &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PvpMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google_lalune::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:boids.PvpMessage.data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace boids

#ifndef SWIG
namespace google_lalune {
namespace protobuf {

template <> struct is_proto_enum< ::boids::UserOperation_OperationType> : ::google_lalune::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::boids::UserOperation_OperationType>() {
  return ::boids::UserOperation_OperationType_descriptor();
}
template <> struct is_proto_enum< ::boids::GameMessage_MessageType> : ::google_lalune::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::boids::GameMessage_MessageType>() {
  return ::boids::GameMessage_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pvp_2eproto__INCLUDED
